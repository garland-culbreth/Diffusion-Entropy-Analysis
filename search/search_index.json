{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Diffusion entropy analysis","text":"<p>Diffusion Entropy Analysis is a time-series analysis method for detecting temporal scaling in a data set, such as particle motion, a seismograph, or an electroencephalograph signal. Diffusion Entropy Analysis converts a timeseries into a diffusion trajectory and uses the entropy of this trajectory to measure the temporal scaling in the data. This is accomplished by moving a window along the trajectory, then using the relationship between the natural logarithm of the length of the window and the Shannon entropy to extract the scaling of the time-series process.</p> <p>For further details about the method and how it works, please see Culbreth, G., Baxley, J. and Lambert, D., 2023. Detecting temporal scaling with modified diffusion entropy analysis. arXiv preprint arXiv:2311.11453.</p>"},{"location":"#installation-and-use","title":"Installation and use","text":"<p>The pymdea package is available on pypi and can be installed with pip: <pre><code>pip install pymdea\n</code></pre> pymdea can also be installed with uv <pre><code>uv add pymdea\n</code></pre></p>"},{"location":"#built-with","title":"Built with","text":""},{"location":"api-reference/core/","title":"pymdea.core","text":"<p>Diffusion entropy analysis core methods.</p>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine","title":"<code>DeaEngine(loader)</code>","text":"<p>Run diffusion entropy analysis.</p> Source code in <code>src/pymdea/core.py</code> <pre><code>def __init__(self: Self, loader: DeaLoader) -&gt; Self:\n    \"\"\"Run diffusion entropy analysis.\"\"\"\n    self.data = loader.data\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_with_stripes","title":"<code>analyze_with_stripes(fit_start, fit_stop, fit_method='siegel', n_stripes=20)</code>","text":"<p>Run a modified diffusion entropy analysis.</p> <p>Parameters:</p> <ul> <li> <code>fit_start</code>               (<code>float</code>)           \u2013            <p>Fraction of maximum window length at which to start linear fit.</p> </li> <li> <code>fit_stop</code>               (<code>float</code>)           \u2013            <p>Fraction of maximum window length at which to stop linear fit.</p> </li> <li> <code>fit_method</code>               (<code>str {\"siegel\", \"theilsen\", \"ls\"}</code>, default:                   <code>'siegel'</code> )           \u2013            <p>Linear fit method to use. By default \"siegel\"</p> </li> <li> <code>n_stripes</code>               (<code>int</code>, default:                   <code>20</code> )           \u2013            <p>Number of stripes to apply to input time-series during analysis.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self @ Engine</code>           \u2013            <p>Object containing the results and inputs of the diffusion entropy analysis.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If n_stripes &lt; 2. At least two stripes must be applied for DEA to provide a meaningful result.</p> </li> </ul> Notes <p>Prefer the siegel or theilsen methods. Least squares linear fits can introduce bias when done over log-scale data, see Clauset, A., Shalizi, C.R. and Newman, M.E., 2009. Power-law distributions in empirical data. SIAM review, 51(4), pp.661-703. https://doi.org/10.1137/070710111. https://arxiv.org/pdf/0706.1062.pdf.</p> Source code in <code>src/pymdea/core.py</code> <pre><code>def analyze_with_stripes(\n    self: Self,\n    fit_start: int,\n    fit_stop: int,\n    fit_method: Literal[\"siegel\", \"theilsen\", \"ls\"] = \"siegel\",\n    n_stripes: int = 20,\n) -&gt; Self:\n    \"\"\"Run a modified diffusion entropy analysis.\n\n    Parameters\n    ----------\n    fit_start : float\n        Fraction of maximum window length at which to start linear fit.\n    fit_stop : float\n        Fraction of maximum window length at which to stop linear fit.\n    fit_method : str {\"siegel\", \"theilsen\", \"ls\"}, optional\n        Linear fit method to use. By default \"siegel\"\n    n_stripes : int, optional, default: 20\n        Number of stripes to apply to input time-series during\n        analysis.\n\n    Returns\n    -------\n    Self @ Engine\n        Object containing the results and inputs of the diffusion\n        entropy analysis.\n\n    Raises\n    ------\n    ValueError\n        If n_stripes &lt; 2. At least two stripes must be applied for\n        DEA to provide a meaningful result.\n\n    Notes\n    -----\n    Prefer the siegel or theilsen methods. Least squares linear\n    fits can introduce bias when done over log-scale data, see\n    Clauset, A., Shalizi, C.R. and Newman, M.E., 2009. Power-law\n    distributions in empirical data. SIAM review, 51(4), pp.661-703.\n    https://doi.org/10.1137/070710111.\n    https://arxiv.org/pdf/0706.1062.pdf.\n\n    \"\"\"\n    if n_stripes &lt; 2:  # noqa: PLR2004\n        msg = \"n_stripes must be greater than 1\"\n        raise ValueError(msg)\n    self.number_of_stripes = n_stripes\n    self.fit_start = fit_start\n    self.fit_stop = fit_stop\n    self.fit_method = fit_method\n    self._apply_stripes()\n    self._get_events()\n    self._make_trajectory()\n    self._calculate_entropy()\n    self._calculate_scaling()\n    self._calculate_mu()\n    self.print_result()\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.analyze_without_stripes","title":"<code>analyze_without_stripes(fit_start, fit_stop, fit_method='siegel')</code>","text":"<p>Run a regular diffusion entropy analysis.</p> <p>Parameters:</p> <ul> <li> <code>fit_start</code>               (<code>float</code>)           \u2013            <p>Fraction of maximum window length at which to start linear fit.</p> </li> <li> <code>fit_stop</code>               (<code>float</code>)           \u2013            <p>Fraction of maximum window length at which to stop linear fit.</p> </li> <li> <code>fit_method</code>               (<code>str {\"siegel\", \"theilsen\", \"ls\"}</code>, default:                   <code>'siegel'</code> )           \u2013            <p>Linear fit method to use. By default \"siegel\"</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self @ Engine</code>           \u2013            <p>Object containing the results and inputs of the diffusion entropy analysis.</p> </li> </ul> Notes <p>Prefer the siegel or theilsen methods. Least squares linear fits can introduce bias when done over log-scale data, see Clauset, A., Shalizi, C.R. and Newman, M.E., 2009. Power-law distributions in empirical data. SIAM review, 51(4), pp.661-703. https://doi.org/10.1137/070710111. https://arxiv.org/pdf/0706.1062.pdf.</p> Source code in <code>src/pymdea/core.py</code> <pre><code>def analyze_without_stripes(\n    self: Self,\n    fit_start: int,\n    fit_stop: int,\n    fit_method: Literal[\"siegel\", \"theilsen\", \"ls\"] = \"siegel\",\n) -&gt; Self:\n    \"\"\"Run a regular diffusion entropy analysis.\n\n    Parameters\n    ----------\n    fit_start : float\n        Fraction of maximum window length at which to start linear fit.\n    fit_stop : float\n        Fraction of maximum window length at which to stop linear fit.\n    fit_method : str {\"siegel\", \"theilsen\", \"ls\"}, optional\n        Linear fit method to use. By default \"siegel\"\n\n    Returns\n    -------\n    Self @ Engine\n        Object containing the results and inputs of the diffusion\n        entropy analysis.\n\n    Notes\n    -----\n    Prefer the siegel or theilsen methods. Least squares linear\n    fits can introduce bias when done over log-scale data, see\n    Clauset, A., Shalizi, C.R. and Newman, M.E., 2009. Power-law\n    distributions in empirical data. SIAM review, 51(4), pp.661-703.\n    https://doi.org/10.1137/070710111.\n    https://arxiv.org/pdf/0706.1062.pdf.\n\n    \"\"\"\n    self.trajectory = self.data\n    self.fit_start = fit_start\n    self.fit_stop = fit_stop\n    self.fit_method = fit_method\n    self._calculate_entropy()\n    self._calculate_scaling()\n    self._calculate_mu()\n    self.print_result()\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaEngine.print_result","title":"<code>print_result()</code>","text":"<p>Print out result of analysis.</p> Source code in <code>src/pymdea/core.py</code> <pre><code>def print_result(self: Self) -&gt; str:\n    \"\"\"Print out result of analysis.\"\"\"\n    self.result = \"--------------------------------- \\n\"\n    self.result = self.result + \"result \\n\"\n    self.result = self.result + f\" \u03b4: {self.delta} \\n\"\n    self.result = self.result + f\" \u03bc (rule 1): {self.mu1} \\n\"\n    self.result = self.result + f\" \u03bc (rule 2): {self.mu2} \\n\"\n    self.result = self.result + \"---------------------------------\"\n    print(self.result)  # noqa: T201\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader","title":"<code>DeaLoader()</code>","text":"<p>Load data for a diffusion entropy analysis.</p> Source code in <code>src/pymdea/core.py</code> <pre><code>def __init__(self: Self) -&gt; Self:\n    \"\"\"Load data for a diffusion entropy analysis.\"\"\"\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.make_diffusion_process","title":"<code>make_diffusion_process(kind='gn', length=10000, a=0)</code>","text":"<p>Generate diffusion process data.</p> <p>Parameters:</p> <ul> <li> <code>kind</code>               (<code>str {\"cn\", \"gn\", \"fgn\", \"fbm\"}</code>, default:                   <code>\"cn\"</code> )           \u2013            <p>Type of diffusion noise to generate. If \"cn\", generate a colored noise with spectral power <code>a</code>. If \"gn\", generate a Gaussian noise. If \"fgn\", generate a fractional Gaussian noise with Hurst index H = <code>a</code>. If \"fbm\", generate a fractional Brownian motion with Hurst index H=<code>a</code>.</p> </li> <li> <code>length</code>               (<code>int</code>, default:                   <code>10000</code> )           \u2013            <p>Length of time-series to generate.</p> </li> <li> <code>a</code>               (<code>(float, optiona)</code>, default:                   <code>0</code> )           \u2013            <p>Only used if <code>kind</code> is \"fgn\", \"fbm\", or \"cn\". If <code>kind</code> is \"fgn\" or \"fbm\", this sets the Hurst index of the process. If <code>kind</code> is \"cn\" this sets the index of the power law spectrum for the noise, 1/(f^<code>a</code>).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self @ Loader</code>           \u2013            <p>An instance of the Loader object.</p> </li> </ul> Source code in <code>src/pymdea/core.py</code> <pre><code>def make_diffusion_process(\n    self: Self,\n    kind: Literal[\"cn\", \"gn\", \"fgn\", \"fbm\"] = \"gn\",\n    length: int = 10000,\n    a: float = 0,\n) -&gt; Self:\n    \"\"\"Generate diffusion process data.\n\n    Parameters\n    ----------\n    kind : str {\"cn\", \"gn\", \"fgn\", \"fbm\"}, optional, default \"cn\"\n        Type of diffusion noise to generate. If \"cn\", generate a\n        colored noise with spectral power `a`. If \"gn\", generate a\n        Gaussian noise. If \"fgn\", generate a fractional Gaussian\n        noise with Hurst index H = `a`. If \"fbm\", generate a\n        fractional Brownian motion with Hurst index H=`a`.\n    length : int, optional, default 10000\n        Length of time-series to generate.\n    a : float, optiona, default 0\n        Only used if `kind` is \"fgn\", \"fbm\", or \"cn\". If `kind` is\n        \"fgn\" or \"fbm\", this sets the Hurst index of the process.\n        If `kind` is \"cn\" this sets the index of the power law\n        spectrum for the noise, 1/(f^`a`).\n\n    Returns\n    -------\n    Self @ Loader\n        An instance of the Loader object.\n\n    \"\"\"\n    if kind == \"gn\":\n        process = stochastic.processes.noise.GaussianNoise()\n        self.data = process.sample(length)\n    if kind == \"cn\":\n        process = stochastic.processes.noise.ColoredNoise(beta=a)\n        self.data = process.sample(length)\n    if kind == \"fgn\":\n        process = stochastic.processes.noise.FractionalGaussianNoise(hurst=a)\n        self.data = process.sample(length)\n    if kind == \"fbm\":\n        process = stochastic.processes.continuous.FractionalBrownianMotion(hurst=a)\n        self.data = process.sample(length)\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.make_sample_data","title":"<code>make_sample_data(length=100000, seed=1)</code>","text":"<p>Generate an array of sample data.</p> <p>Parameters:</p> <ul> <li> <code>length</code>               (<code>int</code>, default:                   <code>100000</code> )           \u2013            <p>Number of time-steps to produce in the sample data.</p> </li> <li> <code>seed</code>               (<code>int</code>, default:                   <code>1</code> )           \u2013            <p>Seed for random number generation.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self @ Loader</code>           \u2013            <p>An instance of the Loader object.</p> </li> </ul> Source code in <code>src/pymdea/core.py</code> <pre><code>def make_sample_data(self: Self, length: int = 100000, seed: int = 1) -&gt; np.ndarray:\n    \"\"\"Generate an array of sample data.\n\n    Parameters\n    ----------\n    length : int, optional, default: 100000\n        Number of time-steps to produce in the sample data.\n    seed : int, optional, default: 1\n        Seed for random number generation.\n\n    Returns\n    -------\n    Self @ Loader\n        An instance of the Loader object.\n\n    \"\"\"\n    rng = np.random.default_rng(seed=seed)\n    random_walk = rng.choice([-1, 1], size=length).cumsum()\n    random_walk[0] = 0  # always start from 0\n    self.seed = seed\n    self.data = random_walk\n    return self\n</code></pre>"},{"location":"api-reference/core/#src.pymdea.core.DeaLoader.read_data_file","title":"<code>read_data_file(filepath, column_name)</code>","text":"<p>Read input data from file.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>System path to a file containing data. Must include the full file name, including the extension. Example: \"/example/path/to/file.csv\"</p> </li> <li> <code>column_name</code>               (<code>str</code>)           \u2013            <p>Name of the column in the data file which contains the time series data values.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self @ Loader</code>           \u2013            <p>An instance of the Loader object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If filepath points to a file of type other than CSV. Support for more types of files is a work in progress.</p> </li> </ul> Source code in <code>src/pymdea/core.py</code> <pre><code>def read_data_file(self: Self, filepath: str, column_name: str) -&gt; pl.DataFrame:\n    \"\"\"Read input data from file.\n\n    Parameters\n    ----------\n    filepath : str\n        System path to a file containing data. Must include the\n        full file name, including the extension. Example:\n        \"/example/path/to/file.csv\"\n    column_name : str\n        Name of the column in the data file which contains the time\n        series data values.\n\n    Returns\n    -------\n    Self @ Loader\n        An instance of the Loader object.\n\n    Raises\n    ------\n    ValueError\n        If filepath points to a file of type other than\n        CSV. Support for more types of files is a work in\n        progress.\n\n    \"\"\"\n    filepath = Path(filepath)\n    supported_types = [\".csv\"]\n    if filepath.suffix not in supported_types:\n        msg = f\"filetype must be one of: {supported_types}.\"\n        raise ValueError(msg)\n    if filepath.suffix == \".csv\":\n        self.data = pl.scan_csv(filepath).select(column_name).to_numpy()\n    return self\n</code></pre>"},{"location":"api-reference/plot/","title":"pymdea.plot","text":"<p>Plotting functions.</p>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter","title":"<code>DeaPlotter(model, theme='ticks', colors='muted')</code>","text":"<p>Plot DEA results.</p> <p>Parameters:</p> <ul> <li> <code>model</code>               (<code>Self @ DeaEngine</code>)           \u2013            <p>Object containing the results of a DEA analysis to be plotted.</p> </li> <li> <code>theme</code>               (<code>str {\"ticks\", \"whitegrid\", \"darkgrid\"}</code>, default:                   <code>\"ticks\"</code> )           \u2013            <p>Name of a seaborn style. Passed through to seaborn.set_theme().</p> </li> <li> <code>colors</code>               (<code>str {\"muted\", \"deep\", \"Set2\", \"tab10\"}</code>, default:                   <code>\"muted\"</code> )           \u2013            <p>Name of a seaborn or matplotlib color palette. Passed through to seaborn.set_theme().</p> </li> </ul> Source code in <code>src/pymdea/plot.py</code> <pre><code>def __init__(\n    self: Self,\n    model: DeaEngine,\n    theme: Literal[\"ticks\", \"whitegrid\", \"darkgrid\"] = \"ticks\",\n    colors: Literal[\"muted\", \"deep\", \"Set2\", \"tab10\"] = \"muted\",\n) -&gt; Self:\n    \"\"\"Plot DEA results.\n\n    Parameters\n    ----------\n    model : Self@DeaEngine\n        Object containing the results of a DEA analysis to be plotted.\n    theme : str {\"ticks\", \"whitegrid\", \"darkgrid\"}, optional, default: \"ticks\"\n        Name of a seaborn style. Passed through to\n        seaborn.set_theme().\n    colors : str {\"muted\", \"deep\", \"Set2\", \"tab10\"}, optional, default: \"muted\"\n        Name of a seaborn or matplotlib color palette. Passed\n        through to seaborn.set_theme().\n\n    \"\"\"\n    sns.set_theme(context=\"notebook\", style=theme, palette=colors)\n    self.window_lengths = model.window_lengths\n    self.entropies = model.entropies\n    self.delta = model.fit_coefficients[0]\n    self.y_intercept = model.fit_coefficients[1]\n    self.mu1 = model.mu1\n    self.mu2 = model.mu2\n</code></pre>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter.mu_candidates","title":"<code>mu_candidates(fig_width=4, fig_height=3)</code>","text":"<p>Plot the possible values of mu.</p> <p>Parameters:</p> <ul> <li> <code>fig_width</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Width, in inches, of the figure.</p> </li> <li> <code>fig_height</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Height, in inches, of the figure.</p> </li> </ul> Source code in <code>src/pymdea/plot.py</code> <pre><code>def mu_candidates(self: Self, fig_width: int = 4, fig_height: int = 3) -&gt; None:\n    \"\"\"Plot the possible values of mu.\n\n    Parameters\n    ----------\n    fig_width : int, optional, default: 4\n        Width, in inches, of the figure.\n    fig_height : int, optional, default: 3\n        Height, in inches, of the figure.\n\n    \"\"\"\n    x1 = np.linspace(1, 2, 100)\n    x2 = np.linspace(2, 3, 100)\n    x3 = np.linspace(3, 4, 100)\n    y1 = x1 - 1\n    y2 = 1 / (x2 - 1)\n    y3 = np.full(100, 0.5)\n\n    fig, ax = plt.subplots(figsize=(fig_width, fig_height))\n    ax.plot(x1, y1, color=\"k\")\n    ax.plot(x2, y2, color=\"k\")\n    ax.plot(x3, y3, color=\"k\")\n    ax.plot(\n        self.mu1,\n        self.delta,\n        marker=\"o\",\n        fillstyle=\"none\",\n        markersize=5,\n        markeredgewidth=2,\n        linestyle=\"none\",\n        label=f\"$\\\\mu$ = {np.round(self.mu1, 2)}\",\n    )\n    ax.plot(\n        self.mu2,\n        self.delta,\n        marker=\"o\",\n        fillstyle=\"none\",\n        markersize=5,\n        markeredgewidth=2,\n        linestyle=\"none\",\n        label=f\"$\\\\mu$ = {np.round(self.mu2, 2)}\",\n    )\n    ax.set_xticks(ticks=np.linspace(1, 4, 7))\n    ax.set_yticks(ticks=np.linspace(0, 1, 5))\n    ax.set_xlabel(\"$\\\\mu$\")\n    ax.set_ylabel(\"$\\\\delta$\")\n    ax.legend(loc=0)\n    ax.grid(visible=True)\n    sns.despine(left=True, bottom=True)\n    plt.show(fig)\n</code></pre>"},{"location":"api-reference/plot/#src.pymdea.plot.DeaPlotter.s_vs_l","title":"<code>s_vs_l(fig_width=4, fig_height=3)</code>","text":"<p>Plot the slope of entropy vs window length.</p> <p>Parameters:</p> <ul> <li> <code>fig_width</code>               (<code>int</code>, default:                   <code>4</code> )           \u2013            <p>Width, in inches, of the figure.</p> </li> <li> <code>fig_height</code>               (<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Height, in inches, of the figure.</p> </li> </ul> Source code in <code>src/pymdea/plot.py</code> <pre><code>def s_vs_l(self: Self, fig_width: int = 4, fig_height: int = 3) -&gt; None:\n    \"\"\"Plot the slope of entropy vs window length.\n\n    Parameters\n    ----------\n    fig_width : int, optional, default: 4\n        Width, in inches, of the figure.\n    fig_height : int, optional, default: 3\n        Height, in inches, of the figure.\n\n    \"\"\"\n    x_line = np.linspace(start=1, stop=np.max(self.window_lengths), num=3)\n    fig, ax = plt.subplots(figsize=(fig_width, fig_height))\n    ax.plot(\n        self.window_lengths,\n        self.entropies,\n        linestyle=\"none\",\n        marker=\"o\",\n        markersize=3,\n        fillstyle=\"none\",\n    )\n    ax.plot(\n        x_line,\n        self.delta * np.log(x_line) + self.y_intercept,\n        color=\"k\",\n        label=f\"$\\\\delta = {np.round(self.delta, 3)}$\",\n    )\n    ax.set_xscale(\"log\")\n    ax.set_xlabel(\"$\\\\ln(L)$\")\n    ax.set_ylabel(\"$S(L)$\")\n    ax.legend(loc=0)\n    sns.despine(trim=True)\n    plt.show(fig)\n</code></pre>"},{"location":"user-guide/further-reading/","title":"Further reading","text":""},{"location":"user-guide/further-reading/#culbreth-g-baxley-j-and-lambert-d-2023","title":"Culbreth, G., Baxley, J. and Lambert, D., 2023","text":"<p>Culbreth, G., Baxley, J. and Lambert, D., 2023. Detecting temporal scaling with modified diffusion entropy analysis. arXiv preprint arXiv:2311.11453</p>"},{"location":"user-guide/further-reading/#culbreth-g-west-bj-and-grigolini-p-2019","title":"Culbreth, G., West, B.J. and Grigolini, P., 2019","text":"<p>Culbreth, G., West, B.J. and Grigolini, P., 2019. Entropic approach to the detection of crucial events. Entropy, 21(2), p.178. doi:10.3390/e21020178</p> <p>Note</p> <ul> <li>This paper introduced the stripes and describes their role with figure examples.</li> <li>This paper used \\(\\eta\\) to denote scaling, rather than \\(\\delta\\).</li> </ul>"},{"location":"user-guide/further-reading/#scafetta-n-and-grigolini-p-2002","title":"Scafetta, N. and Grigolini, P., 2002","text":"<p>Scafetta, N. and Grigolini, P., 2002. Scaling detection in time series: Diffusion entropy analysis. Physical Review E, 66(3), p.036130. doi:10.1103/PhysRevE.66.036130</p> <p>Note</p> <p>The actual algorithm for DEA is detailed (mostly only in words) in Section IV.</p>"},{"location":"user-guide/further-reading/#grigolini-p-palatella-l-and-raffaelli-g-2001","title":"Grigolini, P., Palatella, L. and Raffaelli, G., 2001","text":"<p>Grigolini, P., Palatella, L. and Raffaelli, G., 2001. Asymmetric anomalous diffusion: an efficient way to detect memory in time series. Fractals, 9(04), pp.439-449. doi:10.1142/S0218348X01000865</p> <p>Note</p> <p>This paper introduced always using positive steps when constructing the event array, rather than the sign of the step at that time index.</p>"},{"location":"user-guide/getting-started/","title":"Getting started","text":"In\u00a0[1]: Copied! <pre>from pymdea.core import DeaEngine, DeaLoader\nfrom pymdea.plot import DeaPlotter\n</pre> from pymdea.core import DeaEngine, DeaLoader from pymdea.plot import DeaPlotter In\u00a0[2]: Copied! <pre>dea_loader = DeaLoader()\ndea_loader.make_sample_data(30000)\n</pre> dea_loader = DeaLoader() dea_loader.make_sample_data(30000) Out[2]: <pre>&lt;pymdea.core.DeaLoader at 0x296be3bf8f0&gt;</pre> In\u00a0[3]: Copied! <pre>dea_engine = DeaEngine(dea_loader)\ndea_engine.analyze_with_stripes(fit_start=0.1, fit_stop=0.9, n_stripes=60)\n</pre> dea_engine = DeaEngine(dea_loader) dea_engine.analyze_with_stripes(fit_start=0.1, fit_stop=0.9, n_stripes=60) <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 582/582 [00:00&lt;00:00, 1232.44it/s]\n</pre> <pre>--------------------------------- \nresult \n \u03b4: 0.5078088643108836 \n \u03bc (rule 1): 1.5078088643108836 \n \u03bc (rule 2): 2.9692448680608186 \n---------------------------------\n</pre> In\u00a0[4]: Copied! <pre>dea_plot = DeaPlotter(dea_engine)\n</pre> dea_plot = DeaPlotter(dea_engine) <p>The most illustrative figure is plotting the Shannon entropy against the log of the window lengths, S(L) vs ln(L):</p> In\u00a0[5]: Copied! <pre>dea_plot.s_vs_l()\n</pre> dea_plot.s_vs_l() <p>It's also useful to quickly compare the results of the different rules for computing the <code>mu</code> parameter:</p> In\u00a0[6]: Copied! <pre>dea_plot.mu_candidates()\n</pre> dea_plot.mu_candidates()"},{"location":"user-guide/getting-started/#getting-started","title":"Getting started\u00b6","text":""},{"location":"user-guide/getting-started/#setting-up","title":"Setting up\u00b6","text":""},{"location":"user-guide/getting-started/#with-pip","title":"With pip\u00b6","text":"<p>pymdea is available on PyPI and can be installed with:</p> <pre><code>pip install pymdea\n</code></pre>"},{"location":"user-guide/getting-started/#with-uv","title":"With uv\u00b6","text":"<p>pymdea can also be installed from PyPI with uv:</p> <pre><code>uv add pymdea\n</code></pre>"},{"location":"user-guide/getting-started/#with-uv-from-source","title":"With uv from source\u00b6","text":""},{"location":"user-guide/getting-started/#install-uv","title":"Install uv\u00b6","text":"<p>Install the uv python project manager, following the instructions on uv's official installation guide.</p>"},{"location":"user-guide/getting-started/#clone-pymdea","title":"Clone pymdea\u00b6","text":"<p>Using a command line terminal, clone the pymdea repository to a location on your file system:</p> <pre><code>git clone https://github.com/garland-culbreth/pymdea.git /example/file/path/pymdea.git\n</code></pre>"},{"location":"user-guide/getting-started/#create-environment","title":"Create environment\u00b6","text":"<p>Navigate to the cloned repository directory:</p> <pre><code>cd /example/file/path/pymdea.git\n</code></pre> <p>and run the uv command:</p> <pre><code>uv sync\n</code></pre> <p>This will create a python virtual environment in a subdirectory called <code>.../pymdea.git/.venv</code> which contains a python executable and all packages necessary to run pymdea. The command will display text output in the command line, which should look like this:</p> <pre><code>\u276f uv sync\nUsing Python 3.12.5\nCreating virtualenv at: .venv\nResolved 107 packages in 1.01s\n   Built pymdea @ file:///D:/repos/pymdea.git\nPrepared 101 packages in 819ms\n\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591\u2591 [0/101] Installing\nInstalled 101 packages in 5.05s\n + asttokens==2.4.1\n + attrs==24.2.0\n + babel==2.16.0\n ... (all 101 packages uv installs will be listed out)\n</code></pre> <p>Note: the file path, <code>D:/repos/pymdea.git</code>, is the directory on my own file system my clone of pymdea is located.</p>"},{"location":"user-guide/getting-started/#verify-integrity","title":"Verify integrity\u00b6","text":"<p>To confirm the files work properly, run the uv command:</p> <pre><code>uv run pytest\n</code></pre> <p>This runs the pymdea test suite from <code>test_core.py</code> and display a summary of the results in the command line output.</p> <p>With these steps complete, you're now ready to import the pymdea.core and pymdea.plot modules and work with them!</p>"},{"location":"user-guide/getting-started/#loading-pymdea","title":"Loading pymdea\u00b6","text":"<p>Import the pymdea modules as you would any other Python package.</p>"},{"location":"user-guide/getting-started/#loading-data","title":"Loading data\u00b6","text":"<p>The <code>pymdea.core</code> module provides a <code>DeaLoader</code> class with helper methods for wrangling data. It also has a <code>make_sample_data</code> method for generating sample data for testing purposes, which is what this notebook will use to illustrate an example workflow.</p>"},{"location":"user-guide/getting-started/#analyzing-data","title":"Analyzing data\u00b6","text":"<p>The <code>DeaEngine</code> class from <code>pymdea.core</code> contains the methods for analyzing data once it's been loaded. Pass <code>DeaLoader</code> to <code>DeaEngine</code> to pass the data from the loader to the engine, then invoke the <code>analyze</code> method to run an analysis.</p>"},{"location":"user-guide/getting-started/#viewing-results","title":"Viewing results\u00b6","text":"<p>The <code>DeaPlotter</code> class from <code>pymdea.plot</code> contains methods for viewing the results and producing plots. Pass <code>DeaEngine</code> to <code>DeaPlotter</code> to pass the results from the engine to the plotter, then invoke the plotting methods to view different summaries of the results.</p>"},{"location":"user-guide/interpreting/","title":"Interpreting results","text":""},{"location":"user-guide/interpreting/#fundamentals-and-notation","title":"Fundamentals and notation","text":"<p>The measured scaling of the time-series process is \\(\\delta\\).</p> <p>The \\(\\mu\\) is a complexity index, defined as the power for the inter-event time distribution, \\(\\frac{1}{\\tau^\\mu}\\), where \\(\\tau\\) is inter-event time.</p>"},{"location":"user-guide/interpreting/#frames-of-reference","title":"Frames of reference","text":"<p>For a totally random process, DEA yields \\(\\delta = 0.5\\).</p> <p>The closer \\(\\delta\\) is to 1, and the closer \\(\\mu\\) is to 2, the more complex the data-series is. Those are the critical values of \\(\\delta\\) and \\(\\mu\\).</p> <p>If \\(\\delta &lt; 0.5\\) this usually means the time-series is not complex in the way DEA is designed to quantify.</p>"},{"location":"user-guide/interpreting/#calculating-mu","title":"Calculating mu","text":"<p>Two rules of calculating \\(\\mu\\) are supported:</p> <ul> <li>\\(\\mu = 1 + \\delta\\), holds when \\(1 &lt; \\mu &lt; 2\\)</li> <li>\\(\\mu = 1 + \\frac{1}{\\delta}\\), holds when \\(2 &lt; \\mu &lt; 3\\)</li> </ul> <p>The correct rule for any particular analysis may vary. Because rigorous rules for determining which is correct in what situation have yet to be laid down, both candidates are calculated and plotted so that a user can compare them. Typically the correct value for will lie along the line, as the line represents the theoretical relationship. If you already have an expectation for what rule \\(\\mu\\) should follow, e.g., from theoretical arguments, use that.</p> <p>The theoretical justifications for the two methods of deriving from the scaling are given in Section 3.2 of Scafetta, N., &amp; Grigolini, P. (2002) and Section 3.1-3.2 of Grigolini, P., Palatella, L., &amp; Raffaelli, G. (2001).</p>"},{"location":"user-guide/tuning/","title":"Tuning an analysis","text":""},{"location":"user-guide/tuning/#choosing-number-of-stripes","title":"Choosing number of stripes","text":"<p>Warning</p> <p>Rigorous rules for choosing the proper number of stripes are still being developed.</p> <p>Run a few initial tests with different values. e.g. 10, 50, 100. If there is significant disagreement in the scalings measured, vary about those trial numbers. The correct number of stripes to use is that number such that when varied up or down a little, the scaling does not change.</p>"},{"location":"user-guide/tuning/#choosing-fit-interval","title":"Choosing fit interval","text":"<p>In the result figure, if the results are good, there will be a region in the loglog figure that appears linear. You want the fit interval to line up with this region. \\(S(l)\\) is logged in calculation, \\(\\ln(l)\\) is logged by the scale of the plot. The fitting function accounts for this.</p>"}]}